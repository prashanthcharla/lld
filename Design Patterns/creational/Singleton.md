The Singleton Design Pattern ensures that a class has only one instance and provides global access to it. It’s useful when you need exactly one object to coordinate actions across the system. For instance, managing a single database connection or a logger instance. You can use it for scenarios like database connection management or centralized logging.

Object in java is created using a constructor of a class. Mark that constructor as private so that object can't be created by other programs. But we need an instance. For that create a private static variable of type as same class and assign instance to it. Assigning instance can be done different ways as shown below.

```java
public class MySingleton {
    private static MySingleton singletonObj = null;

    private MySingleton() {}

    public static MySingleton getObject() {
        if(singletonObj == null) {
            // Lazy Initialization
            singletonObj = new MySingleton();
        }

        return singletonObj;
    }
}
```

Above works fine in single threaded but multiple objects can get created due to multiple threads.

```java
public class MySingleton {
    // Eager Initialization
    private static MySingleton singletonObj = new MySingleton();

    private MySingleton() {}

    public static MySingleton getObject() {
        return singletonObj;
    }
}
```

Above avoids creation of multiple instances when accessed by multiple threads problem. But if no thread used, results in waste of resources since JVM creates instance when class is loaded as instance is of static type.

```java
public class MySingleton {
    private static MySingleton singletonObj = null;

    private MySingleton() {}

    public static synchronized MySingleton getObject() {
        if(singletonObj == null) {
            singletonObj = new MySingleton();
        }

        return singletonObj;
    }
}
```

In above, synchronization should be applied to critical section of the code and here object instantiation is the critical section. But it's applied to entire method. For example, if 10 threads accessed method at same time, first thread will apply lock, creates object, returns it and releases lock. Next threads will be in waiting state. For second thread onwards having lock is unnecessary. It creates delay in returning object from second thread till tenth thread.

```java
public class MySingleton {
    private static MySingleton singletonObj = null;

    private MySingleton() {}

    public static MySingleton getObject() {
        if(singletonObj == null) {
            synchronized(MySingleton.class) {
                singletonObj = new MySingleton();
            }
        }

        return singletonObj;
    }
}
```

In above, applied synchronization to only critical section of the code. But if two or more threads accessed at same time, all those threads will end up creating new objets. Let's say two threads acccessed at same time. First thread acquires lock and second thread will be sent to waiting state. After first thread created object, it releases lock and second thread starts running critical section. It will also create a new object.

```java
public class MySingleton {
    private static MySingleton singletonObj = null;

    private MySingleton() {}

    public static MySingleton getObject() {
        if(singletonObj == null) {

            synchronized(MySingleton.class) {
                if(singletonObj == null) {
                    singletonObj = new MySingleton();
                }
            }

        }

        return singletonObj;
    }
}
```

In above, added null check in synchronized block to overcome the object being created multiple times. First null check is needed so that next threads won't run into synchronization. So that they execute faster.

## Can you break above singleton pattern?
Yes. It can be done using Serialization and Refelection.

### Using Serialization
#### Serialization:
Serialization in Java is the process of converting an object’s state into a byte stream. This byte stream contains all the information about the object. This byte stream can then be used to save the object to a file or tranfer over a network. Serialization helps communicate objects between different Java applications and platforms. Some key points related tos serialization are
* Serialization is done using writeObject() method of ObjectOutputStream.
* Deserialization is done using readObject() method of ObjectInputStream.
* Only non static members will be deserialized.

#### hashcode():
It's method of Object class. HashCode in Java is a unique code generated by the JVM at the time of object creation. It serves as an identifier for an object and is used in hashing-related algorithms, such as those used in Hashtable, HashMap, and other collections. 
* The hashCode() method returns an integer value generated by a hashing algorithm which represents the internal memory address of the object.
* Equal objects must have the same hash code (according to their equals() method). Unequal objects may have the same hash code.
* Developers can override this method to provide a custom hash code calculation based on object properties.
* Hash codes play a crucial role in efficient data retrieval and equality checks

```java
public void breakUsingSerialization() {
    MySingleton instance = MySingleton.getObject();
    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream('obj.txt'));
    oos.writeObject(instance);
    oos.close();
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream('obj.txt'));
    MySingleton desrializedInstance = (MySingleton) ois.readObject();
    ois.close();
    System.out.println('Original: '+instance.hashcode());
    System.out.println('Deserialized: '+desrializedInstance.hashcode());
}
```
Printed hash codes will be different which means it broke the singleton pattern. To fix this,

```java
public class MySingleton {
    private static MySingleton singletonObj = null;

    private MySingleton() {}

    public static MySingleton getObject() {
        if(singletonObj == null) {

            synchronized(MySingleton.class) {
                if(singletonObj == null) {
                    singletonObj = new MySingleton();
                }
            }

        }

        return singletonObj;
    }

    public MySingleton readResolve() {
        return singletonObj;
    }
}
```

During the deserialization, JVM calls readResolve method of Object class to convert bytestraem to object. We can override that method and provide our custom implementation. Here we are returning the singleton object. This results in printing same hashcode in our previous code snippet. We solved the issue.

### Using Reflection
Used to inspect the classes, create objects (using constructor) & invoke the methods (including private).

```java
public void breakUsingReflection() {
    Constructor[] constructors = MySingleton.class.getDeclaredConstructors();
    Constructor singletonClassConstructor = constructors[0];
    singletonClassConstructor.setAccessable(true);
    MySingleton instance = MySingleton.getObject();
    MySingleton instanceFromReflection = (MySingleton) singletonClassConstructor.newInstance();
    System.out.println('Original: '+instance.hashcode());
    System.out.println('Reflection: '+desrializedInstance.hashcode());
}
```

Use Enum. It can't be inspected using Reflection and JVM loads enums first which works perfectly with multi threads.

```java
public enum MySingleton {
    INSTANCE;
    public void doSomething() {

    }
}
```

```java
public void useEnumForSingleton() {
    MySingleton instance = MySingleton.INSTANCE;
    // some logic
}
```

#### Real-time example:
* Spring Boot's @Service or @Component
    * Example: When you annotate a class with @Service or @Component, Spring creates one instance per ApplicationContext, making it a singleton.
        ```java
        @Service
        public class UserService { }
        ```
    
        Spring ensures this bean is shared across the app.